<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>MD5 Dice Analyzer</title>
  <style>
    body {
      background: #111;
      color: white;
      font-family: Arial, sans-serif;
    }
    #md5-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0,0,0,0.6);
      color: gold;
      padding: 10px;
      border: 2px solid gold;
      border-radius: 20px;
      font-size: 16px;
      font-weight: bold;
      font-family: monospace;
      z-index: 9999;
      backdrop-filter: blur(5px);
      box-shadow: 0 0 10px gold;
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: move;
    }

    select, button, input {
      background: gold;
      color: black;
      border: none;
      border-radius: 10px;
      padding: 5px 10px;
      font-weight: bold;
      cursor: pointer;
    }

    #bubble {
      white-space: nowrap;
    }

    .dice-edit {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }

    .dice-edit label {
      font-size: 14px;
    }

    .dice-edit input {
      width: 30px;
      text-align: center;
    }
  </style>
</head>
<body>

<div id="md5-container">
  <div id="bubble">üé≤ ƒêang ch·ªù MD5...</div>
  <select id="part-select"></select>
  <button id="refreshBtn">üîÑ L√†m m·ªõi</button>
</div>

<div class="dice-edit">
  <label for="dice-1">‚öÄ: </label>
  <input type="text" id="dice-1" value="‚öÄ" maxlength="1">
  <label for="dice-2">‚öÅ: </label>
  <input type="text" id="dice-2" value="‚öÅ" maxlength="1">
  <label for="dice-3">‚öÇ: </label>
  <input type="text" id="dice-3" value="‚öÇ" maxlength="1">
  <label for="dice-4">‚öÉ: </label>
  <input type="text" id="dice-4" value="‚öÉ" maxlength="1">
  <label for="dice-5">‚öÑ: </label>
  <input type="text" id="dice-5" value="‚öÑ" maxlength="1">
  <label for="dice-6">‚öÖ: </label>
  <input type="text" id="dice-6" value="‚öÖ" maxlength="1">
</div>

<script>
  let diceMap = { 
    1: '‚öÄ', 
    2: '‚öÅ', 
    3: '‚öÇ', 
    4: '‚öÉ', 
    5: '‚öÑ', 
    6: '‚öÖ' 
  };

  let lastCopied = '';
  const bubble = document.getElementById('bubble');
  const select = document.getElementById('part-select');
  const refreshBtn = document.getElementById('refreshBtn');

  // T·∫°o c√°c l·ª±a ch·ªçn chia ph·∫ßn
  for (let i = 3; i <= 18; i++) {
    const option = document.createElement('option');
    option.value = i;
    option.text = `Chia ${i} ph·∫ßn`;
    select.appendChild(option);
  }

  // L·∫Øng nghe s·ª± ki·ªán thay ƒë·ªïi bi·ªÉu t∆∞·ª£ng x√∫c x·∫Øc
  document.querySelectorAll('.dice-edit input').forEach((input, index) => {
    input.addEventListener('input', () => {
      diceMap[index + 1] = input.value;
      updateBubble();
    });
  });

  function parseMd5(md5, parts) {
    const partLength = Math.floor(md5.length / parts);
    const sliced = [];
    for (let i = 0; i < parts; i++) {
      sliced.push(md5.slice(i * partLength, (i + 1) * partLength));
    }
    const mapped = sliced.slice(0, 3).map(p => (parseInt(p, 16) % 6) + 1);
    const total = mapped.reduce((a, b) => a + b, 0);
    return { dice: mapped, total };
  }

  function analyze(total, dice) {
    const count = {};
    for (const n of dice) count[n] = (count[n] || 0) + 1;
    if (Object.values(count).includes(3)) return 'üå™Ô∏è B√£o';
    if (total <= 10) return 'üîµ X·ªâu';
    return 'üî¥ T√†i';
  }

  async function checkClipboard() {
    try {
      const text = await navigator.clipboard.readText();
      const parts = parseInt(select.value);
      if (text !== lastCopied && /^[a-fA-F0-9]{32}$/.test(text)) {
        lastCopied = text;
        const { dice, total } = parseMd5(text, parts);
        const result = analyze(total, dice);
        updateBubble(dice, result);
      }
    } catch (e) {
      console.error('Clipboard read failed:', e);
    }
  }

  function updateBubble(dice = [], result = '') {
    const icons = dice.map(n => diceMap[n]).join(' ');
    bubble.innerText = `${icons} ‚Üí ${result}`;
  }

  // L√†m m·ªõi th·ªß c√¥ng
  refreshBtn.addEventListener('click', checkClipboard);

  // L√†m m·ªõi khi ƒë·ªïi s·ªë ph·∫ßn
  select.addEventListener('change', () => {
    if (lastCopied && /^[a-fA-F0-9]{32}$/.test(lastCopied)) {
      const parts = parseInt(select.value);
      const { dice, total } = parseMd5(lastCopied, parts);
      const result = analyze(total, dice);
      updateBubble(dice, result);
    }
  });

  // T·ª± ƒë·ªông ki·ªÉm tra clipboard m·ªói 1.5s
  setInterval(checkClipboard, 1500);

  // K√©o ƒë∆∞·ª£c bong b√≥ng
  const container = document.getElementById('md5-container');
  let offsetX = 0, offsetY = 0, isDragging = false;

  container.addEventListener('mousedown', function(e) {
    isDragging = true;
    offsetX = e.clientX - container.getBoundingClientRect().left;
    offsetY = e.clientY - container.getBoundingClientRect().top;
  });

  document.addEventListener('mousemove', function(e) {
    if (isDragging) {
      container.style.left = (e.clientX - offsetX) + 'px';
      container.style.top = (e.clientY - offsetY) + 'px';
      container.style.right = 'auto';
      container.style.bottom = 'auto';
    }
  });

  document.addEventListener('mouseup', function() {
    isDragging = false;
  });
</script>

</body>
</html>
</body>
</html>
